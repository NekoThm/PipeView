<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Gem5 Pro Viewer (Flex/O3)</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --header-bg: #252526;
            --border-color: #3e3e42;
            --accent-color: #007acc;
            --text-color: #cccccc;
        }

        body { 
            font-family: 'Segoe UI', 'Consolas', monospace; 
            margin: 0; 
            display: flex; 
            flex-direction: column; 
            height: 100vh; 
            background-color: var(--bg-color); 
            color: var(--text-color);
            overflow: hidden; 
            user-select: none; 
        }
        
        .toolbar { 
            height: 40px;
            padding: 0 16px; 
            background: var(--header-bg); 
            border-bottom: 1px solid var(--border-color); 
            display: flex; 
            gap: 12px; 
            align-items: center; 
            flex-shrink: 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .brand { font-weight: 600; font-size: 14px; color: #fff; margin-right: 5px; }

        .btn {
            background: #3c3c3c;
            border: 1px solid transparent;
            color: #fff;
            padding: 4px 12px;
            font-size: 12px;
            border-radius: 3px;
            cursor: pointer;
            transition: background 0.2s;
            display: inline-flex; align-items: center;
        }
        .btn:hover { background: #505050; }
        .btn-primary { background: var(--accent-color); }
        .btn-primary:hover { background: #0062a3; }
        
        input[type="file"] { display: none; } 

        .input-group { display: flex; align-items: center; gap: 5px; font-size: 12px; }
        .input-group label { color: #aaa; }
        
        input[type="number"] { 
            background: #3c3c3c; 
            border: 1px solid #555; 
            color: #fff; 
            padding: 3px 5px; 
            border-radius: 2px;
            font-family: 'Consolas', monospace;
        }
        
        .range-input { width: 80px; }
        .tick-input { width: 50px; }

        .separator { width: 1px; height: 18px; background: #444; margin: 0 5px; }
        .status { font-size: 11px; margin-left: auto; color: #888; }

        #canvas-wrapper { 
            flex: 1; 
            position: relative; 
            overflow: hidden; 
            background-color: var(--bg-color);
            cursor: default;
            min-height: 0; 
        }
        canvas { display: block; width: 100%; height: 100%; }

        #tooltip {
            position: fixed; display: none;
            background: #2d2d30; border: 1px solid #454545;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            padding: 8px 12px; border-radius: 4px;
            font-size: 12px; color: #eee; z-index: 1000;
            pointer-events: none; min-width: 220px;
        }
        #tooltip h4 { margin: 0 0 6px 0; color: #fff; border-bottom: 1px solid #444; padding-bottom: 4px; }
        #tooltip .row { display: flex; justify-content: space-between; margin-bottom: 2px; }
        #tooltip .key { color: #888; margin-right: 10px; }
        #tooltip .val { font-family: 'Consolas', monospace; color: #4fc1ff; }
        #tooltip .status-tag { color: #ffca28; font-weight: bold; }
    </style>
</head>
<body>

    <div class="toolbar">
        <span class="brand">FLEX/O3 VIEWER</span>
        
        <label class="btn btn-primary">
            Select Trace
            <input type="file" id="fileInput" accept=".out,.txt">
        </label>
        
        <div class="separator"></div>

        <div class="input-group">
            <label>Range:</label>
            <input type="number" id="startTick" class="range-input" placeholder="Start" value="0">
            <span>-</span>
            <input type="number" id="endTick" class="range-input" placeholder="End (Optional)">
        </div>
        
        <button class="btn" onclick="loadData()">Load Data</button>

        <div class="separator"></div>

        <div class="input-group">
            <label>Ticks/Cycle:</label>
            <input type="number" id="cycleTicks" class="tick-input" value="500" step="100">
        </div>

        <span id="status" class="status">Ready</span>
    </div>

    <div id="canvas-wrapper">
        <canvas id="mainCanvas"></canvas>
        <div id="tooltip"></div>
    </div>

<script>
    const O3_STAGES = [
        { name: 'fetch',    short: 'F',  color: '#569cd6' },
        { name: 'decode',   short: 'Dc', color: '#4ec9b0' },
        { name: 'rename',   short: 'Rn', color: '#6a9955' },
        { name: 'dispatch', short: 'Ds', color: '#c586c0' },
        { name: 'issue',    short: 'Is', color: '#ce9178' },
        { name: 'execute',  short: 'Ex', color: '#d16969' }, 
        { name: 'complete', short: 'Cm', color: '#4fc1ff' },
        { name: 'retire',   short: 'Rt', color: '#dcdcaa' },
        { name: 'store',    short: 'St', color: '#9cdcfe' } 
    ];

    const FLEX_STAGES = [
        { name: 'fetch',    short: 'F',  color: '#569cd6' },
        { name: 'decode',   short: 'Dc', color: '#4ec9b0' },
        { name: 'execute',  short: 'Ex', color: '#d16969' }, 
        { name: 'retire',   short: 'Rt', color: '#dcdcaa' }
    ];

    const CONFIG = {
        defaultScaleX: 0.05,
        rowHeight: 28,     
        headerWidth: 350   
    };

    let traceData = [];
    let minTick = 0;
    let currentCpuType = 'O3'; 

    let viewState = {
        scrollX: 0,
        scrollY: 0,
        scaleX: CONFIG.defaultScaleX,
        rowHeight: CONFIG.rowHeight,
        headerWidth: CONFIG.headerWidth,
        dpr: 1
    };

    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const wrapper = document.getElementById('canvas-wrapper');
    const tooltip = document.getElementById('tooltip');
    const cycleTicksInput = document.getElementById('cycleTicks');

    const CommonRenderer = {
        clearAndBackground: function(ctx, width, height) {
            ctx.fillStyle = "#1e1e1e";
            ctx.fillRect(0, 0, width, height);
        },
        
        drawGrid: function(ctx, width, height, ticksPerCycle) {
            const pixelsPerCycle = ticksPerCycle * viewState.scaleX;
            if (pixelsPerCycle > 5) {
                ctx.lineWidth = 1;
                ctx.strokeStyle = "rgba(255, 255, 255, 0.1)"; 
                const visibleStartTick = (viewState.scrollX) / viewState.scaleX; 
                const visibleEndTick = (viewState.scrollX + width - viewState.headerWidth) / viewState.scaleX;
                const startCycleIdx = Math.floor(visibleStartTick / ticksPerCycle);
                const endCycleIdx = Math.ceil(visibleEndTick / ticksPerCycle);
                ctx.beginPath();
                for (let c = startCycleIdx; c <= endCycleIdx; c++) {
                    const x = (c * ticksPerCycle) * viewState.scaleX;
                    ctx.moveTo(x, viewState.scrollY);
                    ctx.lineTo(x, viewState.scrollY + height);
                }
                ctx.stroke();
            }
        },

        drawSidebar: function(ctx, inst, y, yCenter) {
            ctx.fillStyle = (Math.floor(y / viewState.rowHeight) % 2 === 0) ? "#252526" : "#1e1e1e";
            ctx.fillRect(0, y, viewState.headerWidth, viewState.rowHeight);
            
            if (inst.cache_events && inst.cache_events.length > 0) {
                 ctx.fillStyle = "rgba(255, 77, 77, 0.1)"; 
                 ctx.fillRect(0, y, viewState.headerWidth, viewState.rowHeight);
            }

            ctx.strokeStyle = "#2d2d30";
            ctx.beginPath(); ctx.moveTo(0, y + viewState.rowHeight); ctx.lineTo(viewState.headerWidth, y + viewState.rowHeight); ctx.stroke();
            
            ctx.textAlign = "right";
            ctx.fillStyle = (inst.cache_events && inst.cache_events.length > 0) ? "#ff9999" : "#555"; 
            ctx.fillText(inst.id, 45, yCenter);
            
            ctx.textAlign = "left";
            ctx.font = inst.is_flushed ? "italic 12px Consolas" : "12px Consolas";
            ctx.fillStyle = inst.is_flushed ? "#666" : "#ccc";
            let text = inst.disasm;
            if(text.length > 38) text = text.substring(0, 36) + "...";
            ctx.fillText(text, 60, yCenter);
        },
    };

    const O3Renderer = {
        drawO3Pipeline: function(ctx, inst, y, width, ticksPerCycle) {
            const stageConfig = O3_STAGES;
            ctx.globalAlpha = inst.is_flushed ? 0.4 : 1.0;
            for (let s = 0; s < stageConfig.length - 1; s++) {
                const curr = stageConfig[s];
                const t1 = inst.stages[curr.name];
                let nextIdx = s + 1, t2 = null;
                while(nextIdx < stageConfig.length) {
                    if (inst.stages[stageConfig[nextIdx].name]) { t2 = inst.stages[stageConfig[nextIdx].name]; break; }
                    nextIdx++;
                }
                if (t1) {
                    let widthVal = t2 && t2 >= t1 ? (t2 - t1) * viewState.scaleX : Math.max(10, ticksPerCycle * viewState.scaleX);
                    const x = (t1 - minTick) * viewState.scaleX;
                    if (x < viewState.scrollX + width && x + widthVal > viewState.scrollX - viewState.headerWidth) {
                         ctx.fillStyle = curr.color;
                         ctx.fillRect(x, y + 3, widthVal, viewState.rowHeight - 6);
                         if (widthVal > 24) {
                            ctx.fillStyle = "rgba(255,255,255,0.9)"; ctx.textAlign = "center";
                            ctx.fillText(curr.short, x + widthVal/2, y + viewState.rowHeight/2 + 1);
                         }
                    }
                }
            }
            ctx.globalAlpha = 1.0;
        },

        drawCacheEvents: function(ctx, inst, yCenter, width) {
            if (inst.cache_events && inst.cache_events.length > 0) {
                ctx.fillStyle = "#ff4d4d"; 
                inst.cache_events.forEach(e => {
                    const x = (e.tick - minTick) * viewState.scaleX;
                    if (x > viewState.scrollX - 20 && x < viewState.scrollX + width) {
                        ctx.beginPath(); ctx.arc(x, yCenter, 4, 0, Math.PI * 2); ctx.fill();
                        ctx.strokeStyle = "#fff"; ctx.lineWidth = 1; ctx.stroke();
                    }
                });
            }
        }
    };

    const FlexRenderer = {
        drawFlexPipeline: function(ctx, inst, y, width, ticksPerCycle) {
            const stageConfig = FLEX_STAGES;
            ctx.globalAlpha = inst.is_flushed ? 0.4 : 1.0;
            for (let s = 0; s < stageConfig.length; s++) {
                const curr = stageConfig[s];
                const stageData = inst.stages[curr.name];
                
                // Flex 模式：stageData 是对象列表 [{tick, status}, ...]
                if (stageData && Array.isArray(stageData) && stageData.length > 0) {
                    const tStart = stageData[0].tick;
                    const tEnd = stageData[stageData.length - 1].tick;
                    
                    // 绘制宽度：从第一帧到最后一帧，外加一个周期（作为最后一帧的持续时间）
                    const drawWidth = (tEnd - tStart) * viewState.scaleX + (ticksPerCycle * viewState.scaleX);
                    const x = (tStart - minTick) * viewState.scaleX;
                    
                    if (x < viewState.scrollX + width && x + drawWidth > viewState.scrollX - viewState.headerWidth) {
                         ctx.fillStyle = curr.color;
                         ctx.fillRect(x, y + 3, drawWidth, viewState.rowHeight - 6);
                         if (drawWidth > 24) {
                            ctx.fillStyle = "rgba(255,255,255,0.9)"; ctx.textAlign = "center";
                            ctx.fillText(curr.short, x + drawWidth/2, y + viewState.rowHeight/2 + 1);
                         }
                    }
                }
            }
            ctx.globalAlpha = 1.0;
        }
    };

    function draw() {
        const width = canvas.width / viewState.dpr;
        const height = canvas.height / viewState.dpr;
        if (!traceData.length) { CommonRenderer.clearAndBackground(ctx, width, height); return; }
        
        const ticksPerCycle = parseInt(cycleTicksInput.value) || 500;
        CommonRenderer.clearAndBackground(ctx, width, height);

        const startRow = Math.floor(viewState.scrollY / viewState.rowHeight);
        const endRow = Math.min(traceData.length, Math.ceil((viewState.scrollY + height) / viewState.rowHeight));

        ctx.font = "12px 'Segoe UI', Consolas, sans-serif";
        ctx.textBaseline = "middle";

        ctx.save();
        ctx.beginPath(); ctx.rect(viewState.headerWidth, 0, width - viewState.headerWidth, height); ctx.clip();
        ctx.translate(-viewState.scrollX + viewState.headerWidth, -viewState.scrollY);

        for (let i = startRow; i < endRow; i++) {
            const inst = traceData[i], y = i * viewState.rowHeight, yCenter = y + viewState.rowHeight / 2;
            if (currentCpuType === 'Flex') FlexRenderer.drawFlexPipeline(ctx, inst, y, width, ticksPerCycle);
            else {
                O3Renderer.drawO3Pipeline(ctx, inst, y, width, ticksPerCycle);
                O3Renderer.drawCacheEvents(ctx, inst, yCenter, width);
            }
        }
        CommonRenderer.drawGrid(ctx, width, height, ticksPerCycle);
        ctx.restore();

        ctx.save();
        ctx.translate(0, -viewState.scrollY);
        for (let i = startRow; i < endRow; i++) {
            const inst = traceData[i], y = i * viewState.rowHeight;
            CommonRenderer.drawSidebar(ctx, inst, y, y + viewState.rowHeight / 2);
        }
        ctx.restore(); 
        
        ctx.beginPath(); ctx.moveTo(viewState.headerWidth, 0); ctx.lineTo(viewState.headerWidth, height);
        ctx.strokeStyle = "#444"; ctx.lineWidth = 2; ctx.stroke();
    }

    function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        viewState.dpr = dpr;
        const rect = wrapper.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) return;
        canvas.width = rect.width * dpr; canvas.height = rect.height * dpr;
        canvas.style.width = `${rect.width}px`; canvas.style.height = `${rect.height}px`;
        ctx.scale(dpr, dpr); draw();
    }
    const resizeObserver = new ResizeObserver(() => resizeCanvas());
    resizeObserver.observe(wrapper);

    wrapper.addEventListener('wheel', (e) => {
        e.preventDefault();
        if (e.shiftKey) viewState.scrollX = Math.max(0, viewState.scrollX + e.deltaY);
        else { viewState.scrollY = Math.max(0, viewState.scrollY + e.deltaY); viewState.scrollX = Math.max(0, viewState.scrollX + e.deltaX); }
        requestAnimationFrame(draw); updateTooltip(e.clientX, e.clientY);
    }, { passive: false });

    let isDragging = false, lastMouse = { x: 0, y: 0 };
    wrapper.addEventListener('mousedown', (e) => {
        const rect = wrapper.getBoundingClientRect(), x = e.clientX - rect.left, y = e.clientY - rect.top;
        if (x < viewState.headerWidth) {
            const row = Math.floor((y + viewState.scrollY) / viewState.rowHeight);
            if (row >= 0 && row < traceData.length) {
                const fetchStage = traceData[row].stages.fetch;
                let startTickVal = 0;
                // 兼容：Flex 是数组，O3 是数字
                if (Array.isArray(fetchStage) && fetchStage.length > 0) startTickVal = fetchStage[0].tick;
                else if (fetchStage && typeof fetchStage === 'number') startTickVal = fetchStage;
                
                viewState.scrollX = Math.max(0, (startTickVal - minTick) * viewState.scaleX - 20);
                requestAnimationFrame(draw);
            }
        } else { isDragging = true; lastMouse = { x: e.clientX, y: e.clientY }; wrapper.style.cursor = 'grabbing'; tooltip.style.display = 'none'; }
    });
    wrapper.addEventListener('mousemove', (e) => {
        if (isDragging) {
            viewState.scrollX = Math.max(0, viewState.scrollX - (e.clientX - lastMouse.x));
            viewState.scrollY = Math.max(0, viewState.scrollY - (e.clientY - lastMouse.y));
            lastMouse = { x: e.clientX, y: e.clientY }; requestAnimationFrame(draw);
        } else updateTooltip(e.clientX, e.clientY);
    });
    window.addEventListener('mouseup', () => { isDragging = false; wrapper.style.cursor = 'default'; });
    cycleTicksInput.addEventListener('input', () => requestAnimationFrame(draw));

    function updateTooltip(mouseX, mouseY) {
        const rect = wrapper.getBoundingClientRect(), x = mouseX - rect.left, y = mouseY - rect.top;
        if (!traceData.length || isDragging) { tooltip.style.display = 'none'; return; }
        
        const row = Math.floor((y + viewState.scrollY) / viewState.rowHeight);
        if (row < 0 || row >= traceData.length) { tooltip.style.display = 'none'; return; }
        
        const inst = traceData[row];
        const ticksPerCycle = parseInt(cycleTicksInput.value) || 500;
        
        tooltip.style.display = 'block';
        let tx = mouseX + 15, ty = mouseY + 15;
        if (tx + 220 > window.innerWidth) tx = mouseX - 230;
        if (ty + 200 > window.innerHeight) ty = mouseY - 210;
        tooltip.style.left = `${tx}px`; tooltip.style.top = `${ty}px`;

        if (x < viewState.headerWidth) {
            // --- 侧边栏 Hover ---
            let content = `<h4>[${inst.id}] Instruction</h4><div class="row"><span class="key">PC:</span> <span class="val">${inst.pc}</span></div>`;
            content += `<div class="row"><span class="key">Asm:</span> <span class="val" style="color:#fff">${inst.disasm}</span></div><hr style="border:0; border-top:1px solid #444; margin:4px 0;">`;
            const stagesDef = (currentCpuType === 'Flex' ? FLEX_STAGES : O3_STAGES);
            stagesDef.forEach(s => {
                const sData = inst.stages[s.name];
                if (sData) {
                    let disp = "";
                    if (Array.isArray(sData)) disp = sData[0].tick;
                    else disp = (typeof sData === 'object' && sData.tick) ? sData.tick : sData;
                    content += `<div class="row"><span class="key">${s.name}:</span> <span class="val">${disp}</span></div>`;
                }
            });
            if (inst.cache_events?.length > 0) {
                 content += `<hr style="border:0; border-top:1px dashed #666; margin:6px 0;"><div style="color:#ff6b6b; font-weight:bold;">⚠ Cache Miss:</div>`;
                 inst.cache_events.forEach(e => content += `<div style="font-size:11px; border-left:2px solid #ff4d4d; padding-left:4px;">${e.type} @${e.tick}<br>VA:${e.vaddr}</div>`);
            }
            tooltip.innerHTML = content;
        } else {
            // --- 核心：Per-Cycle Status Lookup ---
            const hoverTick = minTick + (x - viewState.headerWidth + viewState.scrollX) / viewState.scaleX;
            let currentStageName = null;
            let currentStageData = null;

            if (currentCpuType === 'Flex') {
                const stagesDef = FLEX_STAGES;
                for (let i = 0; i < stagesDef.length; i++) {
                    const s = stagesDef[i];
                    const dataList = inst.stages[s.name];
                    if (!dataList || !Array.isArray(dataList) || dataList.length === 0) continue;
                    
                    const tStart = dataList[0].tick;
                    const tEnd = dataList[dataList.length - 1].tick + ticksPerCycle; 
                    
                    if (hoverTick >= tStart && hoverTick < tEnd) {
                        // 在列表中寻找小于等于 hoverTick 的最新状态
                        let best = null;
                        for(let item of dataList) {
                            if (item.tick <= hoverTick) best = item;
                            else break; 
                        }
                        if (best && (hoverTick - best.tick) < ticksPerCycle * 1.5) {
                            currentStageName = s.name;
                            currentStageData = best;
                            break;
                        }
                    }
                }
            } else {
                // O3 Legacy Logic
                const stagesDef = O3_STAGES;
                for (let i = 0; i < stagesDef.length; i++) {
                    const s = stagesDef[i];
                    const tStart = inst.stages[s.name];
                    if (!tStart) continue;
                    let tEnd = Infinity;
                    for (let j = i + 1; j < stagesDef.length; j++) {
                        const nextData = inst.stages[stagesDef[j].name];
                        if (nextData) { tEnd = nextData; break; }
                    }
                    if (hoverTick >= tStart && hoverTick < tEnd) {
                        currentStageName = s.name;
                        currentStageData = tStart;
                        break;
                    }
                }
            }

            if (currentStageName) {
                let content = `<h4>Stage: ${currentStageName.toUpperCase()}</h4>`;
                content += `<div class="row"><span class="key">Inst:</span> <span class="val">${inst.disasm}</span></div>`;
                if (currentCpuType === 'Flex') {
                    // 显示状态
                    content += `<div class="row"><span class="key">Status:</span> <span class="val status-tag">${currentStageData.status}</span></div>`;
                    content += `<div class="row"><span class="key">Tick:</span> <span class="val">${currentStageData.tick}</span></div>`;
                } else {
                    content += `<div class="row"><span class="key">Tick:</span> <span class="val">${currentStageData}</span></div>`;
                }
                tooltip.innerHTML = content;
            } else {
                tooltip.style.display = 'none';
            }
        }
    }

    async function loadData() {
        const fileInput = document.getElementById('fileInput');
        if (!fileInput.files[0]) return alert("Please select a file first.");
        const formData = new FormData();
        formData.append('file', fileInput.files[0]);
        formData.append('start_tick', document.getElementById('startTick').value);
        if(document.getElementById('endTick').value) formData.append('end_tick', document.getElementById('endTick').value);

        document.getElementById('status').innerText = "Loading...";
        try {
            const res = await fetch('/upload', { method: 'POST', body: formData });
            const json = await res.json();
            if (json.error) throw new Error(json.error);
            traceData = json.instructions; minTick = json.min_tick; currentCpuType = json.cpu_type || 'O3';
            document.getElementById('status').innerText = `${traceData.length} Insts (${currentCpuType})`;
            viewState.scrollX = 0; viewState.scrollY = 0; resizeCanvas();
        } catch (e) { alert("Error: " + e.message); document.getElementById('status').innerText = "Error"; }
    }
</script>
</body>
</html>
